from ..autogenerated.head_files import HeadFiles
from ..autogenerated.get_files import GetFiles
from ..autogenerated.put_subscriptions import PutSubscriptions
from ..autogenerated.delete_subscriptions import DeleteSubscriptions
from ..autogenerated.post_search import PostSearch
from ..autogenerated.get_search import GetSearch
from ..autogenerated.get_subscriptions import GetSubscriptions
from ..autogenerated.put_files import PutFiles
from ..autogenerated.get_bundles import GetBundles
from ..autogenerated.put_bundles import PutBundles


def head_files(uuid, version=None, **kwargs):
    """
    Given a file UUID, return the metadata for the latest version of that file.  If the version is provided, that
    version's metadata is returned instead.  The metadata is returned in the headers.

    :param uuid: A RFC4122-compliant ID for the file.
    :param version: Timestamp of file creation in RFC3339.  If this is not provided, the latest version is returned.
    """
    return HeadFiles.run(locals())


def get_files(uuid=None, replica=None, version=None, **kwargs):
    """
    Given a file UUID, return the latest version of that file.  If the version is provided, that version of the file
    is returned instead.

    Headers will contain the data store metadata for the file.

    This endpoint will do a HTTP redirect to another HTTP endpoint with the file contents.

    :param uuid: A RFC4122-compliant ID for the file.
    :param replica: Replica to fetch from.
    :param version: Timestamp of file creation in RFC3339.  If this is not provided, the latest version is returned.
    """
    return GetFiles.run(locals())


def put_subscriptions(query, callback_url, replica, **kwargs):
    """
    Create a new event subscription. Every time a new bundle version matches this query,
    a request is sent to callback_url.

    :param callback_url: Url to send request to when a bundle comes in that matches this query.
    :param query: Elasticsearch query that will trigger the callback.
    :param replica: Replica to write to. Can be one of aws, gcp, or azure.
    """
    return PutSubscriptions.run(locals())


def delete_subscriptions(uuid, replica, **kwargs):
    """
    Delete a registered event subscription. The associated query will no longer trigger a callback
    if a matching document is added to the system.

    :param uuid: A RFC4122-compliant ID for the subscription.
    :param replica: Replica to delete from. Can be one of aws, gcp, or azure.
    """
    return DeleteSubscriptions.run(locals())


def post_search(**kwargs):
    """
    Accepts Elasticsearch JSON query and returns matching bundle identifiers

    """
    return PostSearch.run(locals())


def get_search(query, **kwargs):
    """
    Returns a list of bundles matching the given simple criteria

    :param query: Metadata query
    """
    return GetSearch.run(locals())


def get_subscriptions(replica, uuid=None, **kwargs):
    """
    Given a subscription UUID, return the associated subscription, which contains the uuid,
    replica, query, creator_uid, and callback_url.

    :param uuid: A RFC4122-compliant ID for the subscription.
    :param replica: Replica to fetch from. Can be one of aws, gcp, or azure.
    """
    return GetSubscriptions.run(locals())


def put_files(uuid, creator_uid, bundle_uuid, source_url, version=None, **kwargs):
    """
    Create a new version of a file with a given UUID.  The file content is passed in through a cloud URL.  The file
    on the cloud provider must have metadata set reflecting the file checksums and the file content type.

    The metadata fields required are:
    - hca-dss-content-type: content-type of the file
    - hca-dss-sha256: SHA-256 checksum of the file
    - hca-dss-sha1: SHA-1 checksum of the file
    - hca-dss-s3_etag: S3 ETAG checksum of the file.  See
    https://stackoverflow.com/questions/12186993/what-is-the-algorithm-to-compute-the-amazon-s3-etag-for-a-file-larger-than-5gb
    for the general algorithm for how checksum is calculated.  For files smaller than 64MB, this is the MD5 checksum
    of the file.  For files larger than 64MB but smaller than 640,000MB, we use 64MB chunks.  For files larger than
    640,000MB, we use a chunk size equal to the total file size divided by 10000, rounded up to the nearest MB.
    MB, in this section, refers to 1,048,576 bytes.  Note that 640,000MB is not the same as 640GB!
    - hca-dss-crc32c: CRC-32C checksum of the file

    :param uuid: A RFC4122-compliant ID for the bundle.
    :param bundle_uuid: A RFC4122-compliant ID for the bundle that contains this file.
    :param creator_uid: User ID who is creating this file.
    :param source_url: Cloud URL for source data.
    :param version: Timestamp of file creation in RFC3339.  If this is not provided, the latest version is returned.
    """
    return PutFiles.run(locals())


def get_bundles(uuid=None, version=None, replica=None, directurls=None, **kwargs):
    """
    Given a bundle UUID, return the latest version of that bundle.  If the version is provided, that version of the
    bundle is returned instead.

    :param uuid: Bundle unique ID.
    :param directurls: Include direct-access URLs in the response.
    :param replica: Replica to fetch from.
    :param version: Timestamp of bundle creation in RFC3339.
    """
    return GetBundles.run(locals())


def put_bundles(uuid, files, creator_uid, replica, version=None, **kwargs):
    """
    Create a new version of a bundle with a given UUID.  The list of file UUID+versions to be included must be
    provided.

    :param uuid: A RFC4122-compliant ID for the bundle.
    :param creator_uid: User ID who is creating this bundle.
    :param files: indexed: True iff this file should be indexed.
        name: Name of the file.
        uuid: A RFC4122-compliant ID for the file.
        version: Timestamp of file creation in RFC3339.
    :param replica: Replica to write to.
    :param version: Timestamp of bundle creation in RFC3339.
    """
    return PutBundles.run(locals())
